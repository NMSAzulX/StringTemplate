

using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Reflection;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
using StringConsole;




// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        
        public static int Main(string[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls!
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
            HelpAssemblyResolving();
            return AfterAssemblyLoadingAttached(args);
        }

        private static int AfterAssemblyLoadingAttached(string[] args)
        {
            var host = new ConsoleHost(Console.Out, Console.In);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            host.BeforeAnythingElse();

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                Type type = typeof(UniqueProgramName).GetTypeInfo().Assembly.GetType("BenchmarkDotNet.Autogenerated.Runnable");

                type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host });

                return 0;
            }
            catch(Exception ex)
            {
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                host.AfterAll();
            }
        }

        private static void HelpAssemblyResolving()
        {
#if SHADOWCOPY
            AppDomain.CurrentDomain.AssemblyResolve += (_, args) =>
            {
                const string shadowCopyFolderPath = @"";

                var guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

                return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
            };
#endif
        }
    }

    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public class Runnable : global::StringConsole.Test
    {
        public static void Run(IHost host)
        {
            Runnable instance = new Runnable();
            instance.count = 10;

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new Job();
            BenchmarkDotNet.Characteristics.CharacteristicObject.IdCharacteristic[job] = "Core";
                BenchmarkDotNet.Jobs.EnvMode.RuntimeCharacteristic[job] = System.Activator.CreateInstance<BenchmarkDotNet.Environments.CoreRuntime>();
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                MainAction = instance.MainMultiAction,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                IdleAction = instance.IdleMultiAction,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureGcStats = true
            };

            var engine = new BenchmarkDotNet.Engines.EngineFactory().Create(engineParameters);

            instance?.globalSetupAction();
            instance?.iterationSetupAction();

            if (job.ResolveValue(RunMode.RunStrategyCharacteristic, EngineResolver.Instance).NeedsJitting())
				engine.Jitting(); // does first call to main action, must be executed after globalSetup() and iterationSetup()!

            instance?.iterationCleanupAction();

            var results = engine.Run();

            instance?.globalCleanupAction();

            host.ReportResults(results); // printing costs memory, do this after runs

			instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
        }

        public delegate void IdleDelegate();

        public delegate  void TargetDelegate();

        public Runnable()
        {
            globalSetupAction = () => { };
            globalCleanupAction = () => { };
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            idleDelegate = __Idle;
            targetDelegate = TemplateFormat;
            
        }

        private Action globalSetupAction;
        private Action globalCleanupAction;
        private Action iterationSetupAction;
        private Action iterationCleanupAction;
        private IdleDelegate idleDelegate;
        private TargetDelegate targetDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
		// the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
		public int NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
		public void __TrickTheJIT__()
		{
			NotEleven = new Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
		}

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Idle() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE

        private Consumer consumer = new Consumer();

        private void IdleMultiAction(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
                consumer.Consume(idleDelegate());
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
                consumer.Consume(targetDelegate());
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return TemplateFormat();
            }
            
            return default(void);
		}

#elif RETURNS_NON_CONSUMABLE_STRUCT

        private void IdleMultiAction(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
                result = idleDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void MainMultiAction(long invokeCount)
        {
            
            void result = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
                result = targetDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return TemplateFormat();
            }
            
            return default(void);
		}

#elif RETURNS_BYREF

        private void IdleMultiAction(long invokeCount)
        {
            
            void value = default(void);
            for (long i = 0; i < invokeCount; i++)
            {
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
                value = idleDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void mainDefaultValueHolder = default(void);

        private void MainMultiAction(long invokeCount)
        {
            
            ref void alias = ref mainDefaultValueHolder;
            for (long i = 0; i < invokeCount; i++)
            {
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
                alias = targetDelegate();
            }
            DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref TemplateFormat();
            }
            
            return ref mainDefaultValueHolder;
		}
#else

        private void IdleMultiAction(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
                idleDelegate();
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            
            for (long i = 0; i < invokeCount; i++)
            {
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
                targetDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                TemplateFormat();
            }
		}
#endif
    }
}
